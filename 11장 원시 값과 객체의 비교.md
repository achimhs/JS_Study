# [22/08/03] 11장 원시 값과 객체의 비교

원시 값과 객체의 타입은 `세 가지` 측면에서 다르다.

- 원시 타입 값, 즉 원시 값은 `변경 불가능한 값`이다. 반면 객체 타입의 값, 즉 객체는 `변경 가능한 값`이다.
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 `실제 값`이 저장된다. 반면 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 `참조 값`이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 `원시 값`이 복사되어 전달된다. 이를 `값에 의한 전달`이라 한다. 반면 객체는 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 `참조 값`이 복사되어 전달된다. 이를 `참조에 의한 전달`이라 한다.

## 1. 원시 값

### 1-1. 변경 불가능한 값

원시 타입의 값은 `변경 불가능한 값`이다. = 한번 생성된 `원시 값`은 `읽기 전용` 값으로서 변경할 수 없다.

> 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간
> 값: 변수에 저장된 데이터

변경 불가능하다는 것은 `변수`가 아니라 `값`에 대한 진술이다

변수의 상대 개념인 `상수`는 `재할당이 금지된 변수`

✍️ 헷갈리지 말자! 변경이 불가능하다는 것은, 말 그대로 내가 const에 어떤 값을 저장해 놓고 재할당을 하려 했을 때, 값 그자체가 바뀌지 못하고 `새로운 메모리 확보` - `값 저장` - 그리고 `변수가 가리키는 주소가 새로 할당한 그 메모리 공간으로 바뀐다는 것`을 의미한다. 즉, 원래 메모리에 있던 값을 지우고 그 위에 덮어씌우기로 값이 할당되는 것이 아니다.

![](img/%EC%9B%90%EC%8B%9C%EA%B0%92.jpg)

💡불변성: 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 `주소`를 변경한다.

- 불변성을 갖는 원시 값을 할당한 변수는 `재할당` 이외에 변수 값을 변경할 수 있는 방법이 없다.
- 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미한다.

### 1-2. 문자열과 불변성

숫자 값은 1도, 100000도 동일한 8바이트가 필요하지만, 문자열의 경우 1개의 문자로이뤄진 문자열은 2바이트, 10개의 문자로 이뤄진 문자열은 20바이트가 필요하다.

💡유사 배열 객체: 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말함

```javascript
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 접근할 수 있다.
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING
```

```javascript
let str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = "S";

console.log(str); // string
```

하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.

### 1-3. 값에 의한 전달

💡값에 의한 전달이란? 변수에 원시 값을 갖는 변수를 할당하면 변수에는 할당되는 변수의 원시 값이 복사되어 전달되는 것을 의미한다.

```javascript
var score = 80;
var copy = score;

console.log(score, copy); // 80, 80
console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100, 80
console.log(score === copy); // false
```

![](img/%EA%B0%92%EC%97%90%EC%9D%98%ED%95%9C%EC%A0%84%EB%8B%AC.jpg)
scroe변수와 copy변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.

- 변수에는 값이 전달되는 것이 아니라 `메모리 주소`가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.
- `값에 의한 전달`도 사실은 값을 전달하는 것이 아니라 `메모리 주소`를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
- 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 `별개의 값`이 되어 어느 한쪽에서 `재할당`을 통해 값을 변경하더라도 서로 간섭할 수 없는 것이다.

## 2. 객체

### 2-1. 변경 가능한 값

- 객체 타입의 값, 즉 객체는 `변경 가능한 값`이다.

💡참조값: 생성된 객체가 저장된 `메모리 공간의 주소`, 그 자체

```javascript
var person = {
  name: "Lee",
};
```

![](img/%EA%B0%9D%EC%B2%B4%EC%9D%98%ED%95%A0%EB%8B%B9.jpg)

- 원시 값을 할당한 변수는 `값 자체`를 값으로 갖고 / 객체를 할당한 변수는 메모리 주소를 통해 메모리 공간에 접근하여 `참조 값`에 접근한다.

- `원시 값`은 `변경 불가능한 값`이므로 원시 값을 갖는 변수의 값을 변경하려면 `재할당` 외에는 방법이 없다. 하지만 `객체`는 `변경 가능한 값`이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 `직접 변경`할 수 있다. 즉, 재할당 없이 프로퍼티를 동적으로 `추가`할 수도 있고 프로퍼티 값을 `갱신`할 수도 있으며 프로퍼티 자체를 `삭제`할 수도 있다.

```javascript
var person = {
  name: "Lee",
};

// 프로퍼티 값 갱신
person.name = "Kim";

// 프로퍼티 동적 추가
person.address = "Seoul";

console.log(person); // {name: "Kim", address: "Seoul"}
```

![](img/%EA%B0%9D%EC%B2%B4%EB%8A%94%EB%B3%80%EA%B2%BD%EA%B0%80%EB%8A%A5%ED%95%9C%EA%B0%92%EC%9D%B4%EB%8B%A4.jpg)

- 객체의 단점중 하나로는 `여러 개의 식별자`가 `하나의 객체를 공유`할 수 있다는 것이다. 그래서 나온 것이 `깊은 복사`와 `얕은 복사`

- 깊은 복사와 얕은 복사란?
  > 얕은 복사? 객체를 프로퍼티의 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것
  > 깊은 복사? 객체에 중첩되어 있는 객체까지 모두 복사하는 것

📌 참고로, 원본과 복사본은 참조 값이 다른 별개의 객체. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 완전한 복사본을 만든다는 차이가 있음
📌 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있음.

### 2-2. 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되는데, 이를 참조에 의한 전달이라고 한다.

```javascript
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

![](img/%EC%B0%B8%EC%A1%B0%EC%97%90%EC%9D%98%ED%95%9C%EC%A0%84%EB%8B%AC.png)

- 원본 person과 사본 copy는 저장된 `메모리 주소는 다르지만` `동일한 참조 값` = 원본과 사본 모두 `동일한 객체`를 가리킨다 = 두 개의 식별자가 하나의 객체를 `공유`한다는 것
- 따라서, 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고 받는다.

```javascript
var person = {
  name: "Lee",
};

var copy = person;
console.log(copy === person); // true

copy.name = "Kim";

person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy); // {name: "Kim", address: "Seoul"}
```

- "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이나 참조 값이냐의 차이만 있을 뿐이다.
- 자바스크립트는 `"참조에 의한 전달"은 존재하지 않고` `"값에 의한 전달"`만이 존재한다고 말할 수 있다.

```javascript
var person1 = {
  name: "Lee",
};

var person2 = {
  name: "Lee",
};

var person3 = {
  name: "Kyeom",
};

// 프로퍼티는 같지만 다른 메모리에 저장된 별도의 객체이다.
console.log(person1 === person2); // false
// 원시 값 비교
console.log(person1.name === person2.name); // true
console.log(person1.name === person3.name); // false;
```
